#' Cumulative Outer Product Autocovariance Eigendecomposition for Functional Time Series
#'
#' This function performs the eigendecomposition of the cumulative outer product autocovariance operator, denoted D, for functional time series. It is used to estimate factors and loadings in the context of the Otto and Salish (2024) approximate factor model.
#'
#' @param fdaobj An object of class 'fdaobj', typically the output from `fda.preprocess`, representing preprocessed functional time series data.
#' @param q0 The number of cumulative lags to consider in the autocovariance computation. Default is 1.
#' @param start An optional integer specifying the start index for the period over which the eigendecomposition is calculated. If not provided, analysis starts from the beginning of the data series.
#' @param end An optional integer specifying the end index for the period over which the eigendecomposition is calculated. If not provided, analysis goes until the end of the data series.
#'
#'
#' @return
#' Returns an object of class 'fdaobj', containing the following components:
#' \item{densedata}{The dense data from the input object.}
#' \item{workinggrid}{The wirkinggrod from the input object.}
#' \item{operator}{The operator for which the eigenelements are computed. Here: "cumAC_operator".}
#' \item{scores}{The coefficients representing the projections of 'densedata' onto each eigenfunction.}
#' \item{eigenfunctions}{A matrix of orthonormal eigenfunctions derived from the cumulative outer product autocovariance operator.}
#' \item{eigenvalues}{The eigenvalues associated with each eigenfunction, indicating the autocovariance explained by each eigenfunction.}
#' \item{scores.centered}{The projection coefficients after demeaning 'densedata'.}
#' \item{meanfunction}{The sample mean function from the input object.}
#' \item{raw.data}{The raw data from the input object.}
#' \item{observationgrid}{The observation grid from the input object.}
#' 
#'
#' @export
#' @examples
#' # Example with default settings on a standard working grid
#' fed = load.fed()
#' fdaobj = fda.preprocess(data = fed)
#' fts.cumAC(fdaobj)
fts.cumAC = function(fdaobj, q0 = 1, start = NULL, end = NULL){
  ## check input
  if(!(class(fdaobj) == "fdaobj")){
    stop("Please insert an object of class fdaobj generated by the function fda.preprocess.")
  }
  ## check start and end, restrict factors to specified period
  if(is.null(start)){
    start = 1
  } else {
    if((start < 1) || (start > dim(fdaobj$densedata)[1])){
      stop("Please specify valid start.")
    }
  }
  if(is.null(end)){
    end = dim(fdaobj$densedata)[1]
  } else {
    if((end < 1) || (end > dim(fdaobj$densedata)[1])){
      stop("Please specify valid end")
    }
  }
  ## restrict data to specified period
  if(is.ts(fdaobj$densedata)){
    redata = window(fdaobj$densedata, start = time(fdaobj$densedata)[start], end = time(fdaobj$densedata)[end])
  } else {
    redata = window(fdaobj$densedata, start = start, end = end)
  }


  ## number of observations on the curve per time point
  n = dim(redata)[2]
  ## store levels and lags trimmed accordingly for ACF computation
  embedall = embed(redata,q0+1)
  levels = embedall[,1:n]
  ## Compute tau-th order sample autocovariance kernel
  ## and cumulative autocovariance kernel d(r,s)
  D = matrix(0, ncol=n, nrow=n)
  for(tau in 1:q0){
    Ctau = cov(levels, embedall[,(tau*n+1):(n*(tau+1))])
    D = D + Ctau%*%t(Ctau)
  }
  ## #############################################################################
  ## compute eigenfunctions of the cumAC operator
  ## #############################################################################
  ## eigendecomposition of matrix D
  eig = eigen(D)
  ## signs of first entry of eigenvectors
  signs = ifelse((sign(eig$vectors[1,])==-1), -1, 1)
  ## binwidth for rectangular numerical integration based on workinggrid
  binwidth = (rev(fdaobj$workinggrid)[1]-(fdaobj$workinggrid[1]))/length(fdaobj$workinggrid)
  ## flip signs and normalize so that L2norm is 1
  eigenfunctions = t(signs*t(eig$vectors))/sqrt(binwidth)
  ## eig$values corresponds to binwidth=1 (matrixproduct)
  ## multiply with given binwidth to get eigenvalues in L2-sense
  eigenvalues = eig$values*binwidth
  ## compute projection coefficients (scores)
  scores = (fdaobj$densedata %*% eigenfunctions)*binwidth
  ## centered scores and meanfunction (KL)
  scores.centered = scores - matrix(rep(colMeans(scores), dim(scores)[1]), nrow = dim(scores)[1], byrow=TRUE)
  if(is.ts(fdaobj$densedata)){
    scores = ts(scores, start = time(fdaobj$densedata)[1], frequency = frequency(fdaobj$densedata))
    scores.centered = ts(scores.centered, start = time(fdaobj$densedata)[1], frequency = frequency(fdaobj$densedata))
  }
  ## #############################################################################
  ## define column names and transform back to ts if input was ts
  ## #############################################################################
  dimnames(eigenfunctions) = list(fdaobj$workinggrid, paste0("F", 1:n))
  dimnames(scores) = list(1:dim(fdaobj$densedata)[1], paste0("F", 1:n))
  if(is.ts(fdaobj$densedata)){
    scores = ts(scores, start = time(fdaobj$densedata)[1], frequency=frequency(fdaobj$densedata))
  }
  ## output
  out=list(
    "densedata" = fdaobj$densedata,
    "workinggrid" = fdaobj$workinggrid,
    "operator" = "cumAC_operator",
    "scores" = scores,
    "eigenfunctions" = eigenfunctions,
    "eigenvalues" = eigenvalues,
    "scores.centered" = scores.centered,
    "meanfunction" = fdaobj$meanfunction,
    "raw.data" = fdaobj$raw.data,
    "observationgrid" = fdaobj$observationgrid
  )
  class(out) = "fdaobj"
  return(out)
}


